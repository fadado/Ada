--RM 05 Statements

SEQUENCE_OF_STATEMENTS ::= STATEMENT {STATEMENT} {LABEL}

STATEMENT ::= {LABEL} SIMPLE_STATEMENT | {LABEL} COMPOUND_STATEMENT

SIMPLE_STATEMENT ::=
     NULL_STATEMENT
   | ASSIGNMENT_STATEMENT
   | EXIT_STATEMENT
   | GOTO_STATEMENT
   | PROCEDURE_CALL_STATEMENT
   | SIMPLE_RETURN_STATEMENT
   | ENTRY_CALL_STATEMENT
   | REQUEUE_STATEMENT
   | DELAY_STATEMENT
   | ABORT_STATEMENT
   | RAISE_STATEMENT
   | CODE_STATEMENT

COMPOUND_STATEMENT ::=
     IF_STATEMENT
   | CASE_STATEMENT
   | LOOP_STATEMENT
   | BLOCK_STATEMENT
   | EXTENDED_RETURN_STATEMENT
   | PARALLEL_BLOCK_STATEMENT
   | ACCEPT_STATEMENT
   | SELECT_STATEMENT

NULL_STATEMENT ::= null;

LABEL ::= <<label_STATEMENT_IDENTIFIER>>

STATEMENT_IDENTIFIER ::= DIRECT_NAME

ASSIGNMENT_STATEMENT ::= variable_NAME := EXPRESSION;

TARGET_NAME ::= @

IF_STATEMENT ::=
   if CONDITION then
      SEQUENCE_OF_STATEMENTS
   {elsif CONDITION then
      SEQUENCE_OF_STATEMENTS}
   [else
      SEQUENCE_OF_STATEMENTS]
   end if;

CASE_STATEMENT ::=
   case selecting_EXPRESSION is
      CASE_STATEMENT_ALTERNATIVE
      {CASE_STATEMENT_ALTERNATIVE}
   end case;

CASE_STATEMENT_ALTERNATIVE ::=
   when DISCRETE_CHOICE_LIST =>
      SEQUENCE_OF_STATEMENTS

LOOP_STATEMENT ::=
   [loop_STATEMENT_IDENTIFIER :]
      [ITERATION_SCHEME] LOOP
         SEQUENCE_OF_STATEMENTS
      end LOOP [loop_IDENTIFIER];

ITERATION_SCHEME ::=
     while CONDITION
   | for LOOP_PARAMETER_SPECIFICATION
   | for ITERATOR_SPECIFICATION
   | [parallel [ASPECT_SPECIFICATION]]
        for PROCEDURAL_ITERATOR
   | parallel [(CHUNK_SPECIFICATION)] [ASPECT_SPECIFICATION]
        for LOOP_PARAMETER_SPECIFICATION
   | parallel [(CHUNK_SPECIFICATION)] [ASPECT_SPECIFICATION]
        for ITERATOR_SPECIFICATION

CHUNK_SPECIFICATION ::=
     integer_SIMPLE_EXPRESSION
   | DEFINING_IDENTIFIER in DISCRETE_SUBTYPE_DEFINITION

LOOP_PARAMETER_SPECIFICATION ::=
   DEFINING_IDENTIFIER in [reverse] DISCRETE_SUBTYPE_DEFINITION
      [ITERATOR_FILTER]

ITERATOR_FILTER ::= when CONDITION

ITERATOR_SPECIFICATION ::=
     DEFINING_IDENTIFIER [: LOOP_PARAMETER_SUBTYPE_INDICATION]
        in [reverse] iterator_NAME [ITERATOR_FILTER]
   | DEFINING_IDENTIFIER [: LOOP_PARAMETER_SUBTYPE_INDICATION
        of [reverse] iterable_NAME [ITERATOR_FILTER]

LOOP_PARAMETER_SUBTYPE_INDICATION ::=
   SUBTYPE_INDICATION | ACCESS_DEFINITION

PROCEDURAL_ITERATOR ::=
   ITERATOR_PARAMETER_SPECIFICATION of ITERATOR_PROCEDURE_CALL
      [ITERATOR_FILTER]

ITERATOR_PARAMETER_SPECIFICATION ::=
     FORMAL_PART
   | (DEFINING_IDENTIFIER {, DEFINING_IDENTIFIER})

ITERATOR_PROCEDURE_CALL ::=
     procedure_NAME
   | procedure_PREFIX ITERATOR_ACTUAL_PARAMETER_PART

ITERATOR_ACTUAL_PARAMETER_PART ::=
   (ITERATOR_PARAMETER_ASSOCIATION {, ITERATOR_PARAMETER_ASSOCIATION})

ITERATOR_PARAMETER_ASSOCIATION ::=
     PARAMETER_ASSOCIATION | PARAMETER_ASSOCIATION_WITH_BOX

PARAMETER_ASSOCIATION_WITH_BOX ::=
   [formal_parameter_SELECTOR_NAME =>] <>

BLOCK_STATEMENT ::=
   [block_STATEMENT_IDENTIFIER :]
      [DECLARE
         DECLARATIVE_PART]
      begin
         HANDLED_SEQUENCE_OF_STATEMENTS
      end [block_IDENTIFIER];

PARALLEL_BLOCK_STATEMENT ::=
   PARALLEL [(CHUNK_SPECIFICATION)] [ASPECT_SPECIFICATION] do
      SEQUENCE_OF_STATEMENTS
   and
      SEQUENCE_OF_STATEMENTS
   {and
      SEQUENCE_OF_STATEMENTS}
   end do;

EXIT_STATEMENT ::= exit [loop_NAME] [WHEN CONDITION];

GOTO_STATEMENT ::= goto label_NAME;

-- vim:ts=3:sw=3:et:syntax=ada
