--RM 09 Tasks and Synchronization

TASK_TYPE_DECLARATION ::=
   task type DEFINING_IDENTIFIER [KNOWN_DISCRIMINANT_PART]
      [ASPECT_SPECIFICATION] [is
         [new INTERFACE_LIST with]
         TASK_DEFINITION];

SINGLE_TASK_DECLARATION ::=
   task DEFINING_IDENTIFIER
      [ASPECT_SPECIFICATION] [is
         [new INTERFACE_LIST with]
         TASK_DEFINITION];

TASK_DEFINITION ::=
   {TASK_ITEM}
   [private
      {TASK_ITEM}]
   end [task_IDENTIFIER]

TASK_ITEM ::= ENTRY_DECLARATION | ASPECT_CLAUSE

TASK_BODY ::=
   task body DEFINING_IDENTIFIER [ASPECT_SPECIFICATION] is
      DECLARATIVE_PART
   begin
      HANDLED_SEQUENCE_OF_STATEMENTS
   end [task_IDENTIFIER];

PROTECTED_TYPE_DECLARATION ::=
   protected type DEFINING_IDENTIFIER [KNOWN_DISCRIMINANT_PART]
      [ASPECT_SPECIFICATION] is
         [new INTERFACE_LIST with]
         PROTECTED_DEFINITION;

SINGLE_PROTECTED_DECLARATION ::=
   protected DEFINING_IDENTIFIER
      [ASPECT_SPECIFICATION] is
         [new INTERFACE_LIST with]
         PROTECTED_DEFINITION;

PROTECTED_DEFINITION ::=
   {PROTECTED_OPERATION_DECLARATION}
   [private
      {PROTECTED_ELEMENT_DECLARATION}]
   end [protected_IDENTIFIER]

PROTECTED_OPERATION_DECLARATION ::=
     SUBPROGRAM_DECLARATION
   | ENTRY_DECLARATION
   | ASPECT_CLAUSE

PROTECTED_ELEMENT_DECLARATION ::=
     PROTECTED_OPERATION_DECLARATION
   | COMPONENT_DECLARATION

PROTECTED_BODY ::=
   protected body DEFINING_IDENTIFIER [ASPECT_SPECIFICATION] is
      {PROTECTED_OPERATION_ITEM}
   end [protected_IDENTIFIER];

PROTECTED_OPERATION_ITEM ::=
     SUBPROGRAM_DECLARATION
   | SUBPROGRAM_BODY
   | NULL_PROCEDURE_DECLARATION
   | EXPRESSION_FUNCTION_DECLARATION
   | ENTRY_BODY
   | ASPECT_CLAUSE

SYNCHRONIZATION_KIND ::=
   `By_Entry` | `By_Protected_Procedure` | `Optional`

ENTRY_DECLARATION ::=
   [OVERRIDING_INDICATOR]
   entry DEFINING_IDENTIFIER [(DISCRETE_SUBTYPE_DEFINITION)]
      PARAMETER_PROFILE [ASPECT_SPECIFICATION];

ACCEPT_STATEMENT ::=
   accept entry_DIRECT_NAME [(ENTRY_INDEX)] PARAMETER_PROFILE [do
      HANDLED_SEQUENCE_OF_STATEMENTS
   end [entry_IDENTIFIER]];

ENTRY_INDEX ::= EXPRESSION

ENTRY_BODY ::=
   entry DEFINING_IDENTIFIER ENTRY_BODY_FORMAL_PART
      [ASPECT_SPECIFICATION]
   ENTRY_BARRIER is
      DECLARATIVE_PART
   begin
      HANDLED_SEQUENCE_OF_STATEMENTS
   end [entry_IDENTIFIER];

ENTRY_BODY_FORMAL_PART ::=
   [(ENTRY_INDEX_SPECIFICATION)] PARAMETER_PROFILE

ENTRY_BARRIER ::= when CONDITION

ENTRY_INDEX_SPECIFICATION ::=
   for DEFINING_IDENTIFIER
   in DISCRETE_SUBTYPE_DEFINITION [ASPECT_SPECIFICATION]

ENTRY_CALL_STATEMENT ::= entry_NAME [ACTUAL_PARAMETER_PART];

REQUEUE_STATEMENT ::= requeue procedure_or_entry_NAME [with abort];

DELAY_STATEMENT ::= DELAY_UNTIL_STATEMENT | DELAY_RELATIVE_STATEMENT

DELAY_UNTIL_STATEMENT ::= delay until delay_EXPRESSION;

DELAY_RELATIVE_STATEMENT ::= delay delay_EXPRESSION;

SELECT_STATEMENT ::=
     SELECTIVE_ACCEPT
   | TIMED_ENTRY_CALL
   | CONDITIONAL_ENTRY_CALL
   | ASYNCHRONOUS_SELECT

SELECTIVE_ACCEPT ::=
   select
      [GUARD] SELECT_ALTERNATIVE
   {or
      [GUARD] SELECT_ALTERNATIVE}
   [else
      SEQUENCE_OF_STATEMENTS]
   end select;

GUARD ::= when CONDITION =>

SELECT_ALTERNATIVE ::=
     ACCEPT_ALTERNATIVE
   | DELAY_ALTERNATIVE
   | TERMINATE_ALTERNATIVE

ACCEPT_ALTERNATIVE ::= ACCEPT_STATEMENT [SEQUENCE_OF_STATEMENTS]

DELAY_ALTERNATIVE ::= DELAY_STATEMENT [SEQUENCE_OF_STATEMENTS]

TERMINATE_ALTERNATIVE ::= terminate;

TIMED_ENTRY_CALL ::=
   select
      ENTRY_CALL_ALTERNATIVE
   or
      DELAY_ALTERNATIVE
   end select;

ENTRY_CALL_ALTERNATIVE ::=
   PROCEDURE_OR_ENTRY_CALL [SEQUENCE_OF_STATEMENTS]

PROCEDURE_OR_ENTRY_CALL ::=
   PROCEDURE_CALL_STATEMENT | ENTRY_CALL_STATEMENT

CONDITIONAL_ENTRY_CALL ::=
   select
      ENTRY_CALL_ALTERNATIVE
   else
      SEQUENCE_OF_STATEMENTS
   end select;

ASYNCHRONOUS_SELECT ::=
   select
      TRIGGERING_ALTERNATIVE
   then abort
      ABORTABLE_PART
   end select;

TRIGGERING_ALTERNATIVE ::= TRIGGERING_STATEMENT [SEQUENCE_OF_STATEMENTS]

TRIGGERING_STATEMENT ::= PROCEDURE_OR_ENTRY_CALL | DELAY_STATEMENT

ABORTABLE_PART ::= SEQUENCE_OF_STATEMENTS

ABORT_STATEMENT ::= abort task_NAME {, task_NAME};

-- vim:ts=3:sw=3:et:syntax=ada
