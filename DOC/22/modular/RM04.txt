--RM 04 Names and Expressions

NAME ::=
     DIRECT_NAME
   | EXPLICIT_DEREFERENCE
   | INDEXED_COMPONENT
   | SLICE
   | SELECTED_COMPONENT
   | ATTRIBUTE_REFERENCE
   | TYPE_CONVERSION
   | FUNCTION_CALL
   | CHARACTER_LITERAL
   | QUALIFIED_EXPRESSION
   | GENERALIZED_REFERENCE
   | GENERALIZED_INDEXING
   | TARGET_NAME

DIRECT_NAME ::= IDENTIFIER | OPERATOR_SYMBOL

PREFIX ::= NAME | IMPLICIT_DEREFERENCE

EXPLICIT_DEREFERENCE ::= NAME.all

IMPLICIT_DEREFERENCE ::= NAME

INDEXED_COMPONENT ::= PREFIX(EXPRESSION {, EXPRESSION})

SLICE ::= PREFIX(DISCRETE_RANGE)

SELECTED_COMPONENT ::= PREFIX.SELECTOR_NAME

SELECTOR_NAME ::= IDENTIFIER | CHARACTER_LITERAL | OPERATOR_SYMBOL

ATTRIBUTE_REFERENCE ::=
     PREFIX'ATTRIBUTE_DESIGNATOR
   | REDUCTION_ATTRIBUTE_REFERENCE

ATTRIBUTE_DESIGNATOR ::=
     IDENTIFIER [(static_EXPRESSION)]
   | `Access` | `Delta` | `Digits` | `Mod`

RANGE_ATTRIBUTE_REFERENCE ::= PREFIX'RANGE_ATTRIBUTE_DESIGNATOR

RANGE_ATTRIBUTE_DESIGNATOR ::= `Range`[(static_EXPRESSION)]

GENERALIZED_REFERENCE ::= reference_object_NAME

GENERALIZED_INDEXING ::=
   indexable_container_object_PREFIX ACTUAL_PARAMETER_PART

AGGREGATE ::=
     RECORD_AGGREGATE
   | EXTENSION_AGGREGATE 
   | ARRAY_AGGREGATE
   | DELTA_AGGREGATE 
   | CONTAINER_AGGREGATE

RECORD_AGGREGATE ::= (RECORD_COMPONENT_ASSOCIATION_LIST)

RECORD_COMPONENT_ASSOCIATION_LIST ::=
     RECORD_COMPONENT_ASSOCIATION {, RECORD_COMPONENT_ASSOCIATION}
   | null record

RECORD_COMPONENT_ASSOCIATION ::=
     [COMPONENT_CHOICE_LIST =>] EXPRESSION
   | COMPONENT_CHOICE_LIST => <>

COMPONENT_CHOICE_LIST ::=
     component_SELECTOR_NAME {`|` component_SELECTOR_NAME}
   | others

EXTENSION_AGGREGATE ::=
   (ANCESTOR_PART with RECORD_COMPONENT_ASSOCIATION_LIST)

ANCESTOR_PART ::= EXPRESSION | SUBTYPE_MARK

ARRAY_AGGREGATE ::=
     POSITIONAL_ARRAY_AGGREGATE
   | NULL_ARRAY_AGGREGATE
   | NAMED_ARRAY_AGGREGATE

POSITIONAL_ARRAY_AGGREGATE ::=
     (EXPRESSION , EXPRESSION {, EXPRESSION})
   | (EXPRESSION {, EXPRESSION}, others => EXPRESSION)
   | (EXPRESSION {, EXPRESSION}, others => <>)
   | `[` EXPRESSION {, EXPRESSION}[, others => EXPRESSION] `]`
   | `[` EXPRESSION {, EXPRESSION}, others => <> `]`

NULL_ARRAY_AGGREGATE ::= `[` `]`

NAMED_ARRAY_AGGREGATE ::=
     (ARRAY_COMPONENT_ASSOCIATION_LIST)
   | `[` ARRAY_COMPONENT_ASSOCIATION_LIST `]`

ARRAY_COMPONENT_ASSOCIATION_LIST ::=
   ARRAY_COMPONENT_ASSOCIATION {, ARRAY_COMPONENT_ASSOCIATION}

ARRAY_COMPONENT_ASSOCIATION ::=
     DISCRETE_CHOICE_LIST => EXPRESSION
   | DISCRETE_CHOICE_LIST => <>
   | ITERATED_COMPONENT_ASSOCIATION

ITERATED_COMPONENT_ASSOCIATION ::=
     for DEFINING_IDENTIFIER in DISCRETE_CHOICE_LIST => EXPRESSION
   | for ITERATOR_SPECIFICATION => EXPRESSION

DELTA_AGGREGATE ::= RECORD_DELTA_AGGREGATE | ARRAY_DELTA_AGGREGATE

RECORD_DELTA_AGGREGATE ::=
   (base_EXPRESSION with delta RECORD_COMPONENT_ASSOCIATION_LIST)

ARRAY_DELTA_AGGREGATE ::=
     (base_EXPRESSION with delta ARRAY_COMPONENT_ASSOCIATION_LIST)
   | `[` base_EXPRESSION with delta ARRAY_COMPONENT_ASSOCIATION_LIST `]`

CONTAINER_AGGREGATE ::=
     NULL_CONTAINER_AGGREGATE
   | POSITIONAL_CONTAINER_AGGREGATE
   | NAMED_CONTAINER_AGGREGATE

NULL_CONTAINER_AGGREGATE ::= `[` `]`

POSITIONAL_CONTAINER_AGGREGATE ::= `[` EXPRESSION {, EXPRESSION} `]`

NAMED_CONTAINER_AGGREGATE ::= `[` CONTAINER_ELEMENT_ASSOCIATION_LIST `]`

CONTAINER_ELEMENT_ASSOCIATION_LIST ::=
   CONTAINER_ELEMENT_ASSOCIATION {, CONTAINER_ELEMENT_ASSOCIATION}

CONTAINER_ELEMENT_ASSOCIATION ::=
     KEY_CHOICE_LIST => EXPRESSION
   | KEY_CHOICE_LIST => <>
   | ITERATED_ELEMENT_ASSOCIATION

KEY_CHOICE_LIST ::= KEY_CHOICE {`|` KEY_CHOICE}

KEY_CHOICE ::= key_EXPRESSION | DISCRETE_RANGE

ITERATED_ELEMENT_ASSOCIATION ::=
     for LOOP_PARAMETER_SPECIFICATION [use key_EXPRESSION] => EXPRESSION
   | for ITERATOR_SPECIFICATION [use key_EXPRESSION] => EXPRESSION

EXPRESSION ::=
     RELATION {and RELATION}
   | RELATION {or RELATION}
   | RELATION {xor RELATION}
   | RELATION {and then RELATION}
   | RELATION {or else RELATION}

CHOICE_EXPRESSION ::=
     CHOICE_RELATION {and CHOICE_RELATION}
   | CHOICE_RELATION {or CHOICE_RELATION}
   | CHOICE_RELATION {xor CHOICE_RELATION}
   | CHOICE_RELATION {and then CHOICE_RELATION}
   | CHOICE_RELATION {or else CHOICE_RELATION}

CHOICE_RELATION ::=
   SIMPLE_EXPRESSION [RELATIONAL_OPERATOR SIMPLE_EXPRESSION]

RELATION ::=
     SIMPLE_EXPRESSION [RELATIONAL_OPERATOR SIMPLE_EXPRESSION]
   | tested_SIMPLE_EXPRESSION [not] in MEMBERSHIP_CHOICE_LIST
   | RAISE_EXPRESSION

MEMBERSHIP_CHOICE_LIST ::= MEMBERSHIP_CHOICE {`|` MEMBERSHIP_CHOICE}

MEMBERSHIP_CHOICE ::= choice_SIMPLE_EXPRESSION | RANGE | SUBTYPE_MARK

SIMPLE_EXPRESSION ::=
   [UNARY_ADDING_OPERATOR] TERM {BINARY_ADDING_OPERATOR TERM}

TERM ::= FACTOR {MULTIPLYING_OPERATOR FACTOR}

FACTOR ::= PRIMARY [** PRIMARY] | abs PRIMARY | not PRIMARY

PRIMARY ::=
     NUMERIC_LITERAL
   | null
   | STRING_LITERAL
   | AGGREGATE
   | NAME
   | ALLOCATOR
   | (EXPRESSION)
   | (CONDITIONAL_EXPRESSION)
   | (QUANTIFIED_EXPRESSION)
   | (DECLARE_EXPRESSION)

LOGICAL_OPERATOR ::= and | or | xor

RELATIONAL_OPERATOR ::= = | /= | < | <= | > | >=

BINARY_ADDING_OPERATOR ::= + | – | &

UNARY_ADDING_OPERATOR ::= + | –

MULTIPLYING_OPERATOR ::= * | / | mod | rem

HIGHEST_PRECEDENCE_OPERATOR ::= ** | abs | not

CONDITIONAL_EXPRESSION ::= IF_EXPRESSION | CASE_EXPRESSION

IF_EXPRESSION ::=
   if CONDITION then dependent_EXPRESSION
   {elsif CONDITION then dependent_EXPRESSION}
   [else dependent_EXPRESSION]

CONDITION ::= boolean_EXPRESSION

CASE_EXPRESSION ::=
   case selecting_EXPRESSION is
      CASE_EXPRESSION_ALTERNATIVE {, CASE_EXPRESSION_ALTERNATIVE}

CASE_EXPRESSION_ALTERNATIVE ::=
   when DISCRETE_CHOICE_LIST =>
      dependent_EXPRESSION

QUANTIFIED_EXPRESSION ::=
     for QUANTIFIER LOOP_PARAMETER_SPECIFICATION => PREDICATE
   | for QUANTIFIER ITERATOR_SPECIFICATION => PREDICATE

QUANTIFIER ::= all | some

PREDICATE ::= boolean_EXPRESSION

DECLARE_EXPRESSION ::=
   declare {DECLARE_ITEM}
   begin body_EXPRESSION

DECLARE_ITEM ::= OBJECT_DECLARATION | OBJECT_RENAMING_DECLARATION

REDUCTION_ATTRIBUTE_REFERENCE ::=
     VALUE_SEQUENCE'REDUCTION_ATTRIBUTE_DESIGNATOR
   | PREFIX'REDUCTION_ATTRIBUTE_DESIGNATOR

VALUE_SEQUENCE ::=
   `[` [parallel [(CHUNK_SPECIFICATION)] [ASPECT_SPECIFICATION]]
      ITERATED_ELEMENT_ASSOCIATION `]`

REDUCTION_ATTRIBUTE_DESIGNATOR ::=
   reduction_IDENTIFIER(REDUCTION_SPECIFICATION)

REDUCTION_SPECIFICATION ::= reducer_NAME , initial_value_EXPRESSION

TYPE_CONVERSION ::= SUBTYPE_MARK(EXPRESSION) | SUBTYPE_MARK(NAME)

QUALIFIED_EXPRESSION ::=
   SUBTYPE_MARK'(EXPRESSION) | SUBTYPE_MARK'AGGREGATE

ALLOCATOR ::=
     new [SUBPOOL_SPECIFICATION] SUBTYPE_INDICATION
   | new [SUBPOOL_SPECIFICATION] QUALIFIED_EXPRESSION

SUBPOOL_SPECIFICATION ::= (subpool_handle_NAME)

-- vim:ts=3:sw=3:et:syntax=ada
